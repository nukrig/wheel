{
  "version": 3,
  "sources": ["../../../../../../node_modules/spin-wheel-ts/dist/util.js", "../../../../../../node_modules/spin-wheel-ts/dist/constants.js", "../../../../../../node_modules/spin-wheel-ts/dist/events.js", "../../../../../../node_modules/spin-wheel-ts/dist/item.js", "../../../../../../node_modules/spin-wheel-ts/dist/wheel.js"],
  "sourcesContent": ["/**\n * Get a random integer between `min` (inclusive) and `max` (exclusive).\n */\nexport function getRandomInt(min = 0, max = 0) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min)) + min;\n}\n/**\n * Get a random number between `min` (inclusive) and `max` (inclusive).\n * Control the number of decimal places with `round`.\n */\nexport function getRandomFloat(min = 0, max = 0, round = 14) {\n    return parseFloat((Math.random() * (max - min) + min).toFixed(round));\n}\n/**\n * Convert degrees to radians.\n */\nexport function degRad(degrees = 0) {\n    return (degrees * Math.PI) / 180;\n}\n/**\n * Return true if `angle` is between `arcStart` (inclusive) and `arcEnd` (exclusive).\n * Example: `(0, 359, 1) == true`\n * Example: `(0, 1, 2) == false`\n */\nexport function isAngleBetween(angle, arcStart, arcEnd) {\n    if (arcStart < arcEnd)\n        return arcStart <= angle && angle < arcEnd;\n    return arcStart <= angle || angle < arcEnd;\n}\n/**\n * Average the values in `array`.\n * Only operate on truthy values.\n * Truthy values that are not Numbers count as 1.\n * Return 0 if the array is empty.\n */\nexport function aveArray(array = []) {\n    let sum = 0;\n    for (const val of array) {\n        if (val)\n            sum += typeof val === 'number' ? val : 1;\n    }\n    return sum / array.length || 0;\n}\n/**\n * Calculate the largest font size that `text` can have without exceeding `maxWidth`.\n * Won't work unless `fontFamily` has been loaded.\n */\nexport function getFontSizeToFit(text, fontFamily, maxWidth, canvasContext) {\n    canvasContext.save();\n    canvasContext.font = `1px ${fontFamily}`;\n    const w = canvasContext.measureText(text).width;\n    canvasContext.restore();\n    return maxWidth / w;\n}\n/**\n * Return true if the given point is inside a circle.\n * cx, cy is circle center.\n * radius is circle radius.\n */\nexport function isPointInCircle(point = { x: 0, y: 0 }, cx, cy, radius) {\n    const distanceSquared = (point.x - cx) ** 2 + (point.y - cy) ** 2;\n    return distanceSquared <= radius ** 2;\n}\n/**\n * Translate the given point from the viewport's coordinate space to the element's coordinate space.\n */\nexport function translateXYToElement(point = { x: 0, y: 0 }, element, devicePixelRatio = 1) {\n    const rect = element.getBoundingClientRect();\n    return {\n        x: (point.x - rect.left) * devicePixelRatio,\n        y: (point.y - rect.top) * devicePixelRatio,\n    };\n}\nexport function getMouseButtonsPressed(event) {\n    return [1, 2, 4, 8, 16].filter((i) => event.buttons & i);\n}\n/**\n * Source: https://stackoverflow.com/a/47653643/737393\n */\nexport function getAngle(originX, originY, targetX, targetY) {\n    const dx = originX - targetX;\n    const dy = originY - targetY;\n    let theta = Math.atan2(-dy, -dx);\n    theta *= 180 / Math.PI;\n    if (theta < 0)\n        theta += 360;\n    return theta;\n}\n/**\n * Return the distance between two points.\n */\nexport function getDistanceBetweenPoints(point1 = { x: 0, y: 0 }, point2 = { x: 0, y: 0 }) {\n    return Math.hypot(point2.x - point1.x, point2.y - point1.y);\n}\n/**\n * Add two angles together.\n * Return a positive number between 0 and 359.9999.\n */\nexport function addAngle(a = 0, b = 0) {\n    const sum = a + b;\n    let result;\n    if (sum > 0) {\n        result = sum % 360;\n    }\n    else {\n        result = 360 + (sum % 360);\n    }\n    if (result === 360)\n        result = 0;\n    return result;\n}\n/**\n * Return the shortest difference (in degrees) between two angles.\n * Only accept angles between 0 and 360.\n */\nexport function diffAngle(a = 0, b = 0) {\n    const offsetFrom180 = 180 - b;\n    const aWithOffset = addAngle(a, offsetFrom180);\n    return 180 - aWithOffset;\n}\n/**\n * Calculate what the new rotation of a wheel should be, so that the relative angle `targetAngle` will be at 0 degrees (north).\n * targetAngle = a value between 0 and 360.\n * direction = the direction the wheel can spin. 1 for clockwise, -1 for antiClockwise.\n */\nexport function calcWheelRotationForTargetAngle(currentRotation = 0, targetAngle = 0, direction = 1) {\n    let angle = ((currentRotation % 360) + targetAngle) % 360;\n    // Ignore tiny values.\n    // Due to floating point arithmetic, ocassionally the input angles won't add up exactly\n    // and this can push the angle slightly above 360.\n    angle = fixFloat(angle);\n    // Apply direction:\n    angle = (direction === 1 ? 360 - angle : 360 + angle) % 360;\n    angle *= direction;\n    return currentRotation + angle;\n}\nexport function isObject(v) {\n    return typeof v === 'object' && !Array.isArray(v) && v !== null;\n}\nexport function isNumber(n) {\n    return typeof n === 'number' && !Number.isNaN(n);\n}\nexport function setProp({ val, isValid, errorMessage, defaultValue, action, }) {\n    if (isValid) {\n        return action ? action() : val === undefined ? defaultValue : val;\n    }\n    else if (val === undefined) {\n        return defaultValue;\n    }\n    throw new Error(errorMessage);\n}\n/**\n * Return true if image has loaded.\n */\nexport function isImageLoaded(image) {\n    // We can detect a broken image (didn't load) by checking the natural width/height.\n    return (image &&\n        image.complete &&\n        image.naturalWidth !== 0 &&\n        image.naturalHeight !== 0);\n}\nexport function fixFloat(f = 0) {\n    return Number(f.toFixed(9));\n}\n/**\n * Easing function.\n */\nexport function easeSinOut(n) {\n    return Math.sin((n * Math.PI) / 2);\n}\n", "/**\n * Adjustment when drawing arcs to ensure 0° is north (due to canvas drawing arcs from 90°).\n */\nexport const arcAdjust = -90;\nexport const baseCanvasSize = 500; // 500 seemed to be a good value for this.\n/**\n * The period in milliseconds that we record drag events.\n * Used to calculate how fast the wheel should spin after the drag ends.\n * For example, if the wheel was dragged 20 degrees over the last 250ms,\n * then it should continue rotating at a speed of 20 degrees every 250ms after the drag ends.\n */\nexport const dragCapturePeriod = 250;\n/**\n * Text alignment enum.\n */\nexport const AlignText = Object.freeze({\n    left: 'left',\n    right: 'right',\n    center: 'center',\n});\n/**\n * Wheel property defaults.\n */\nexport const Defaults = Object.freeze({\n    wheel: {\n        borderColor: '#000',\n        borderWidth: 1,\n        debug: false,\n        image: null,\n        isInteractive: true,\n        itemBackgroundColors: ['#fff'],\n        itemLabelAlign: AlignText.right,\n        itemLabelBaselineOffset: 0,\n        itemLabelColors: ['#000'],\n        itemLabelFont: 'sans-serif',\n        itemLabelFontSizeMax: baseCanvasSize,\n        itemLabelRadius: 0.85,\n        itemLabelRadiusMax: 0.2,\n        itemLabelRotation: 0,\n        itemLabelStrokeColor: '#fff',\n        itemLabelStrokeWidth: 0,\n        items: [],\n        lineColor: '#000',\n        lineWidth: 1,\n        pixelRatio: 0,\n        radius: 0.95,\n        rotation: 0,\n        rotationResistance: -35,\n        rotationSpeedMax: 300,\n        offset: { w: 0, h: 0 },\n        onCurrentIndexChange: null,\n        onRest: null,\n        onSpin: null,\n        overlayImage: null,\n        pointerAngle: 0,\n    },\n    item: {\n        backgroundColor: null,\n        image: null,\n        imageOpacity: 1,\n        imageRadius: 0.5,\n        imageRotation: 0,\n        imageScale: 1,\n        label: '',\n        labelColor: null,\n        value: null,\n        weight: 1,\n    },\n});\nexport const Debugging = Object.freeze({\n    pointerLineColor: '#ff00ff',\n    labelOutlineColor: '#ff00ff',\n    labelRadiusColor: '#00ff00',\n    dragEventHue: 200,\n});\n", "export function register(wheel) {\n    registerPointerEvents(wheel);\n    // Listen for when the window is resized.\n    wheel._handler_onResize = () => wheel.resize();\n    window.addEventListener('resize', wheel._handler_onResize);\n    // Listen for when window.devicePixelRatio changes.\n    // For example, when the browser window is moved to a different screen.\n    // Note: Chrome Version 116 raises the `resize` event when `window.devicePixelRatio` changes,\n    // and so does Firefox 117 but sometimes it raises it twice (shrug).\n    // However Safari 16.3 doesn't, hence we need to monitor this separately.\n    const listenForDevicePixelRatioChange = () => {\n        wheel._mediaQueryList = window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);\n        wheel._mediaQueryList.addEventListener('change', wheel._handler_onDevicePixelRatioChange, { once: true });\n    };\n    wheel._handler_onDevicePixelRatioChange = () => {\n        wheel.resize();\n        listenForDevicePixelRatioChange();\n    };\n    listenForDevicePixelRatioChange();\n}\nexport function unregister(wheel) {\n    const canvas = wheel.canvas;\n    if (!!canvas) {\n        if ('PointerEvent' in window) {\n            canvas.removeEventListener('pointerdown', wheel._handler_onPointerDown);\n            canvas.removeEventListener('pointermove', wheel._handler_onPointerMoveRefreshCursor);\n        }\n        else {\n            canvas.removeEventListener('touchstart', wheel._handler_onTouchStart);\n            canvas.removeEventListener('mousedown', wheel._handler_onMouseDown);\n            canvas.removeEventListener('mousemove', wheel._handler_onMouseMoveRefreshCursor);\n        }\n    }\n    window.removeEventListener('resize', wheel._handler_onResize);\n    wheel._mediaQueryList?.removeEventListener('change', wheel._handler_onDevicePixelRatioChange);\n}\nfunction registerPointerEvents(wheel) {\n    // Adapted from https://glitch.com/~jake-in-the-box\n    const canvas = wheel.canvas;\n    if (!canvas)\n        return;\n    wheel._handler_onPointerMoveRefreshCursor = (e) => {\n        const point = {\n            x: e.clientX,\n            y: e.clientY,\n        };\n        wheel._isCursorOverWheel = wheel.wheelHitTest(point);\n        wheel.refreshCursor();\n    };\n    wheel._handler_onMouseMoveRefreshCursor = (e) => {\n        const point = {\n            x: e.clientX,\n            y: e.clientY,\n        };\n        wheel._isCursorOverWheel = wheel.wheelHitTest(point);\n        wheel.refreshCursor();\n    };\n    wheel._handler_onPointerDown = (e) => {\n        const point = {\n            x: e.clientX,\n            y: e.clientY,\n        };\n        if (!wheel.isInteractive)\n            return;\n        if (!wheel.wheelHitTest(point))\n            return;\n        e.preventDefault();\n        wheel.dragStart(point);\n        canvas.setPointerCapture(e.pointerId);\n        canvas.addEventListener('pointermove', onPointerMove);\n        canvas.addEventListener('pointerup', onPointerUp);\n        canvas.addEventListener('pointercancel', onPointerUp);\n        canvas.addEventListener('pointerout', onPointerUp);\n        function onPointerMove(e) {\n            e.preventDefault();\n            wheel.dragMove({\n                x: e.clientX,\n                y: e.clientY,\n            });\n        }\n        function onPointerUp(e) {\n            e.preventDefault();\n            if (!canvas)\n                return;\n            canvas.releasePointerCapture(e.pointerId);\n            canvas.removeEventListener('pointermove', onPointerMove);\n            canvas.removeEventListener('pointerup', onPointerUp);\n            canvas.removeEventListener('pointercancel', onPointerUp);\n            canvas.removeEventListener('pointerout', onPointerUp);\n            wheel.dragEnd();\n        }\n    };\n    wheel._handler_onMouseDown = (e) => {\n        const point = {\n            x: e.clientX,\n            y: e.clientY,\n        };\n        if (!wheel.isInteractive)\n            return;\n        if (!wheel.wheelHitTest(point))\n            return;\n        wheel.dragStart(point);\n        document.addEventListener('mousemove', onMouseMove);\n        document.addEventListener('mouseup', onMouseUp);\n        function onMouseMove(e) {\n            e.preventDefault();\n            wheel.dragMove({\n                x: e.clientX,\n                y: e.clientY,\n            });\n        }\n        function onMouseUp(e) {\n            e.preventDefault();\n            document.removeEventListener('mousemove', onMouseMove);\n            document.removeEventListener('mouseup', onMouseUp);\n            wheel.dragEnd();\n        }\n    };\n    wheel._handler_onTouchStart = (e) => {\n        const point = {\n            x: e.targetTouches[0].clientX,\n            y: e.targetTouches[0].clientY,\n        };\n        if (!wheel.isInteractive)\n            return;\n        if (!wheel.wheelHitTest(point))\n            return;\n        e.preventDefault();\n        wheel.dragStart(point);\n        canvas.addEventListener('touchmove', onTouchMove);\n        canvas.addEventListener('touchend', onTouchEnd);\n        canvas.addEventListener('touchcancel', onTouchEnd);\n        function onTouchMove(e) {\n            e.preventDefault();\n            wheel.dragMove({\n                x: e.targetTouches[0].clientX,\n                y: e.targetTouches[0].clientY,\n            });\n        }\n        function onTouchEnd(e) {\n            e.preventDefault();\n            if (!canvas)\n                return;\n            canvas.removeEventListener('touchmove', onTouchMove);\n            canvas.removeEventListener('touchend', onTouchEnd);\n            canvas.removeEventListener('touchcancel', onTouchEnd);\n            wheel.dragEnd();\n        }\n    };\n    if ('PointerEvent' in window) {\n        canvas.addEventListener('pointerdown', wheel._handler_onPointerDown);\n        canvas.addEventListener('pointermove', wheel._handler_onPointerMoveRefreshCursor);\n    }\n    else {\n        canvas.addEventListener('touchstart', wheel._handler_onTouchStart);\n        canvas.addEventListener('mousedown', wheel._handler_onMouseDown);\n        canvas.addEventListener('mousemove', wheel._handler_onMouseMoveRefreshCursor);\n    }\n}\n", "import * as util from './util.js';\nimport { Defaults } from './constants.js';\nexport class Item {\n    _wheel;\n    _backgroundColor = Defaults.item.backgroundColor;\n    _image = Defaults.item.image;\n    _imageOpacity = Defaults.item.imageOpacity;\n    _imageRadius = Defaults.item.imageRadius;\n    _imageRotation = Defaults.item.imageRotation;\n    _imageScale = Defaults.item.imageScale;\n    _label = Defaults.item.label;\n    _labelColor = Defaults.item.labelColor;\n    _value = Defaults.item.value;\n    _weight = Defaults.item.weight;\n    path;\n    constructor(wheel, props) {\n        // Validate params.\n        if (!util.isObject(wheel)) {\n            throw new Error('wheel must be an instance of Wheel'); // Ideally we would use instanceof, however importing the Wheel class would create a circular ref.\n        }\n        if (!util.isObject(props) && props !== null) {\n            throw new Error('props must be an Object or null');\n        }\n        this._wheel = wheel;\n        if (props) {\n            this.init(props);\n        }\n        else {\n            this.init(Defaults.item);\n        }\n    }\n    /**\n     * Initialise all properties.\n     */\n    init(props) {\n        this.backgroundColor = props.backgroundColor;\n        this.image = props.image;\n        this.imageOpacity = props.imageOpacity;\n        this.imageRadius = props.imageRadius;\n        this.imageRotation = props.imageRotation;\n        this.imageScale = props.imageScale;\n        this.label = props.label;\n        this.labelColor = props.labelColor;\n        this.value = props.value;\n        this.weight = props.weight;\n    }\n    /**\n     * The background color of the item.\n     * When `null`, the actual color rendered will fall back to `Wheel.itemBackgroundColors`.\n     * Example: `'#fff'`.\n     */\n    get backgroundColor() {\n        return this._backgroundColor;\n    }\n    set backgroundColor(val) {\n        if (typeof val === 'string') {\n            this._backgroundColor = val;\n        }\n        else {\n            this._backgroundColor = Defaults.item.backgroundColor;\n        }\n        this._wheel.refresh();\n    }\n    /**\n     * The url of an image that will be drawn on the item.\n     * Any part of the image that extends outside the item will be clipped.\n     * The image will be drawn over the top of `Item.backgroundColor`.\n     */\n    get image() {\n        return this._image;\n    }\n    set image(val) {\n        let img;\n        if (typeof val === 'string') {\n            img = new Image();\n            img.src = val;\n            img.onload = (e) => this._wheel.refresh();\n        }\n        else {\n            img = Defaults.item.image;\n        }\n        this._image = img;\n        this._wheel.refresh();\n    }\n    /**\n     * The opacity (as a percent) of `Item.image`.\n     * Useful if you want to fade the image to make the item's label stand out.\n     */\n    get imageOpacity() {\n        return this._imageOpacity;\n    }\n    set imageOpacity(val) {\n        if (typeof val === 'number') {\n            this._imageOpacity = val;\n        }\n        else {\n            this._imageOpacity = Defaults.item.imageOpacity;\n        }\n        this._wheel.refresh();\n    }\n    /**\n     * The point along the radius (as a percent, starting from the center of the wheel) to draw the center of `Item.image`.\n     */\n    get imageRadius() {\n        return this._imageRadius;\n    }\n    set imageRadius(val) {\n        if (typeof val === 'number') {\n            this._imageRadius = val;\n        }\n        else {\n            this._imageRadius = Defaults.item.imageRadius;\n        }\n        this._wheel.refresh();\n    }\n    /**\n     * The rotation (angle in degrees) of `Item.image`.\n     */\n    get imageRotation() {\n        return this._imageRotation;\n    }\n    set imageRotation(val) {\n        if (typeof val === 'number') {\n            this._imageRotation = val;\n        }\n        else {\n            this._imageRotation = Defaults.item.imageRotation;\n        }\n        this._wheel.refresh();\n    }\n    /**\n     * The scale (as a percent) to resize `Item.image`.\n     */\n    get imageScale() {\n        return this._imageScale;\n    }\n    set imageScale(val) {\n        if (typeof val === 'number') {\n            this._imageScale = val;\n        }\n        else {\n            this._imageScale = Defaults.item.imageScale;\n        }\n        this._wheel.refresh();\n    }\n    /**\n     * The text that will be drawn on the item.\n     */\n    get label() {\n        return this._label;\n    }\n    set label(val) {\n        if (typeof val === 'string') {\n            this._label = val;\n        }\n        else {\n            this._label = Defaults.item.label;\n        }\n        this._wheel.refresh();\n    }\n    /**\n     * The color of the label.\n     * When `null`, the actual color rendered will fall back to `Wheel.itemLabelColors`.\n     * Example: `'#000'`.\n     */\n    get labelColor() {\n        return this._labelColor;\n    }\n    set labelColor(val) {\n        if (typeof val === 'string') {\n            this._labelColor = val;\n        }\n        else {\n            this._labelColor = Defaults.item.labelColor;\n        }\n        this._wheel.refresh();\n    }\n    /**\n     * Some value that has meaning to your application.\n     * For example, a reference to the object representing the item on the wheel, or a database id.\n     */\n    get value() {\n        return this._value;\n    }\n    set value(val) {\n        if (!!val) {\n            this._value = val;\n        }\n        else {\n            this._value = Defaults.item.value;\n        }\n    }\n    /**\n     * The proportional size of the item relative to other items on the wheel.\n     * For example, if you have 2 items where `item[0]` has a weight of `1` and `item[1]` has a weight of `2`,\n     * then `item[0]` will take up 1/3 of the space on the wheel.\n     */\n    get weight() {\n        return this._weight;\n    }\n    set weight(val) {\n        if (typeof val === 'number') {\n            this._weight = val;\n        }\n        else {\n            this._weight = Defaults.item.weight;\n        }\n    }\n    /**\n     * Get the 0-based index of this item.\n     */\n    getIndex() {\n        const index = this._wheel.items.findIndex((i) => i === this);\n        if (index === -1)\n            throw new Error('Item not found in parent Wheel');\n        return index;\n    }\n    /**\n     * Get the angle (in degrees) that this item ends at (exclusive), ignoring the current `rotation` of the wheel.\n     */\n    getCenterAngle() {\n        const angle = this._wheel.getItemAngles()[this.getIndex()];\n        if (!angle) {\n            throw new Error('Item not found in parent Wheel');\n        }\n        return angle.start + (angle.end - angle.start) / 2;\n    }\n    /**\n     * Get the angle (in degrees) that this item starts at (inclusive), ignoring the current `rotation` of the wheel.\n     */\n    getStartAngle() {\n        const angle = this._wheel.getItemAngles()[this.getIndex()];\n        if (!angle) {\n            throw new Error('Item not found in parent Wheel');\n        }\n        return angle.start;\n    }\n    /**\n     * Get the angle (in degrees) that this item ends at (inclusive), ignoring the current `rotation` of the wheel.\n     */\n    getEndAngle() {\n        const angle = this._wheel.getItemAngles()[this.getIndex()];\n        if (!angle) {\n            throw new Error('Item not found in parent Wheel');\n        }\n        return angle.end;\n    }\n    /**\n     * Return a random angle (in degrees) between this item's start angle (inclusive) and end angle (inclusive).\n     */\n    getRandomAngle() {\n        return util.getRandomFloat(this.getStartAngle(), this.getEndAngle());\n    }\n}\n", "import * as util from './util.js';\nimport * as Constants from './constants.js';\nimport { Defaults } from './constants.js';\nimport * as events from './events.js';\nimport { Item } from './item.js';\nclass Wheel {\n    _frameRequestId = null;\n    _rotationSpeed = 0;\n    _rotationDirection = 0;\n    _spinToTimeStart = 0; // Used to animate the wheel for spinTo()\n    _spinToTimeEnd = null; // Used to animate the wheel for spinTo()\n    _lastSpinFrameTime = null; // Used to animate the wheel for spinTo()\n    _isCursorOverWheel = false;\n    _isInitialising = false;\n    _borderColor = Defaults.wheel.borderColor;\n    _borderWidth = Defaults.wheel.borderWidth;\n    _debug = Defaults.wheel.debug;\n    _image = Defaults.wheel.image;\n    _isInteractive = Defaults.wheel.isInteractive;\n    _itemBackgroundColors = Defaults.wheel.itemBackgroundColors;\n    _itemLabelAlign = Defaults.wheel.itemLabelAlign;\n    _itemLabelBaselineOffset = Defaults.wheel.itemLabelBaselineOffset;\n    _itemLabelColors = Defaults.wheel.itemLabelColors;\n    _itemLabelFont = Defaults.wheel.itemLabelFont;\n    _itemLabelFontSizeMax = Defaults.wheel.itemLabelFontSizeMax;\n    _itemLabelRadius = Defaults.wheel.itemLabelRadius;\n    _itemLabelRadiusMax = Defaults.wheel.itemLabelRadiusMax;\n    _itemLabelRotation = Defaults.wheel.itemLabelRotation;\n    _itemLabelStrokeColor = Defaults.wheel.itemLabelStrokeColor;\n    _itemLabelStrokeWidth = Defaults.wheel.itemLabelStrokeWidth;\n    _items = Defaults.wheel.items;\n    _lineColor = Defaults.wheel.lineColor;\n    _lineWidth = Defaults.wheel.lineWidth;\n    _offset = Defaults.wheel.offset;\n    _onCurrentIndexChange = Defaults.wheel.onCurrentIndexChange;\n    _onRest = Defaults.wheel.onRest;\n    _onSpin = Defaults.wheel.onSpin;\n    _overlayImage = Defaults.wheel.overlayImage;\n    _pixelRatio = Defaults.wheel.pixelRatio;\n    _radius = Defaults.wheel.radius;\n    _rotation = Defaults.wheel.rotation;\n    _rotationResistance = Defaults.wheel.rotationResistance;\n    _spinToEasingFunction = util.easeSinOut;\n    canvas = null;\n    _canvasContainer = null;\n    _context = null;\n    _size = 0;\n    _center = { x: 0, y: 0 };\n    _actualRadius = 0;\n    _currentIndex = -1;\n    _pointerAngle = Defaults.wheel.pointerAngle;\n    _rotationSpeedMax = Defaults.wheel.rotationSpeedMax;\n    itemLabelFontSize = 0;\n    labelMaxWidth = 0;\n    dragEvents = [];\n    isDragging = false;\n    _spinToStartRotation = 0;\n    _spinToEndRotation = 0;\n    _handler_onResize = () => { };\n    _handler_onDevicePixelRatioChange = () => { };\n    _handler_onPointerMoveRefreshCursor = () => { };\n    _handler_onPointerDown = () => { };\n    _handler_onMouseDown = () => { };\n    _handler_onTouchStart = () => { };\n    _handler_onMouseMoveRefreshCursor = () => { };\n    _mediaQueryList = undefined;\n    /**\n     * Create the wheel inside a container Element and initialise it with props.\n     * `container` must be an Element.\n     * `props` must be an Object or null.\n     */\n    constructor(container, props) {\n        this.add(container);\n        this._isInitialising = true;\n        this.borderColor = props.borderColor;\n        this.borderWidth = props.borderWidth;\n        this.debug = props.debug;\n        this.image = props.image;\n        this.isInteractive = props.isInteractive;\n        this.itemBackgroundColors = props.itemBackgroundColors;\n        this.itemLabelAlign = props.itemLabelAlign;\n        this.itemLabelBaselineOffset = props.itemLabelBaselineOffset;\n        this.itemLabelColors = props.itemLabelColors;\n        this.itemLabelFont = props.itemLabelFont;\n        this.itemLabelFontSizeMax = props.itemLabelFontSizeMax;\n        this.itemLabelRadius = props.itemLabelRadius;\n        this.itemLabelRadiusMax = props.itemLabelRadiusMax;\n        this.itemLabelRotation = props.itemLabelRotation;\n        this.itemLabelStrokeColor = props.itemLabelStrokeColor;\n        this.itemLabelStrokeWidth = props.itemLabelStrokeWidth;\n        this.items = props.items;\n        this.lineColor = props.lineColor;\n        this.lineWidth = props.lineWidth;\n        this.pixelRatio = props.pixelRatio;\n        this.rotationSpeedMax = props.rotationSpeedMax;\n        this.radius = props.radius;\n        this.rotation = props.rotation;\n        this.rotationResistance = props.rotationResistance;\n        this.offset = props.offset;\n        this.onCurrentIndexChange = props.onCurrentIndexChange;\n        this.onRest = props.onRest;\n        this.onSpin = props.onSpin;\n        this.overlayImage = props.overlayImage;\n        this.pointerAngle = props.pointerAngle;\n    }\n    /**\n     * Initialise all properties.\n     */\n    init(props) {\n        this._isInitialising = true;\n        this.borderColor = props.borderColor;\n        this.borderWidth = props.borderWidth;\n        this.debug = props.debug;\n        this.image = props.image;\n        this.isInteractive = props.isInteractive;\n        this.itemBackgroundColors = props.itemBackgroundColors;\n        this.itemLabelAlign = props.itemLabelAlign;\n        this.itemLabelBaselineOffset = props.itemLabelBaselineOffset;\n        this.itemLabelColors = props.itemLabelColors;\n        this.itemLabelFont = props.itemLabelFont;\n        this.itemLabelFontSizeMax = props.itemLabelFontSizeMax;\n        this.itemLabelRadius = props.itemLabelRadius;\n        this.itemLabelRadiusMax = props.itemLabelRadiusMax;\n        this.itemLabelRotation = props.itemLabelRotation;\n        this.itemLabelStrokeColor = props.itemLabelStrokeColor;\n        this.itemLabelStrokeWidth = props.itemLabelStrokeWidth;\n        this.items = props.items;\n        this.lineColor = props.lineColor;\n        this.lineWidth = props.lineWidth;\n        this.pixelRatio = props.pixelRatio;\n        this.rotationSpeedMax = props.rotationSpeedMax;\n        this.radius = props.radius;\n        this.rotation = props.rotation;\n        this.rotationResistance = props.rotationResistance;\n        this.offset = props.offset;\n        this.overlayImage = props.overlayImage;\n        this.pointerAngle = props.pointerAngle;\n        this.onCurrentIndexChange = props.onCurrentIndexChange;\n        this.onRest = props.onRest;\n        this.onSpin = props.onSpin;\n    }\n    /**\n     * Add the wheel to the DOM and register event handlers.\n     */\n    add(container) {\n        this._canvasContainer = container;\n        this.canvas = document.createElement('canvas');\n        this._context = this.canvas.getContext('2d');\n        this._canvasContainer.append(this.canvas);\n        events.register(this);\n        if (this._isInitialising === false)\n            this.resize(); // Initalise the canvas's dimensions (but not when called from the constructor).\n    }\n    /**\n     * Remove the wheel from the DOM and unregister event handlers.\n     */\n    remove() {\n        if (!this.canvas || !this._canvasContainer) {\n            return;\n        }\n        if (this._frameRequestId !== null) {\n            window.cancelAnimationFrame(this._frameRequestId);\n        }\n        events.unregister(this);\n        this._canvasContainer.removeChild(this.canvas);\n        this._canvasContainer = null;\n        this.canvas = null;\n        this._context = null;\n    }\n    /**\n     * Resize the wheel to fit inside it's container.\n     * Call this after changing any property of the wheel that relates to it's size or position.\n     */\n    resize() {\n        if (!this.canvas || !this._canvasContainer || !this._context) {\n            return;\n        }\n        // Set the dimensions of the canvas element to be the same as its container:\n        this.canvas.style.width = this._canvasContainer.clientWidth + 'px';\n        this.canvas.style.height = this._canvasContainer.clientHeight + 'px';\n        // Calc the actual pixel dimensions that will be drawn:\n        // See https://www.khronos.org/webgl/wiki/HandlingHighDPI\n        const [w, h] = [\n            this._canvasContainer.clientWidth * this.getActualPixelRatio(),\n            this._canvasContainer.clientHeight * this.getActualPixelRatio(),\n        ];\n        this.canvas.width = w;\n        this.canvas.height = h;\n        // Calc the size that the wheel needs to be to fit in it's container:\n        const min = Math.min(w, h);\n        const wheelSize = {\n            w: min - min * this.offset.w,\n            h: min - min * this.offset.h,\n        };\n        const scale = Math.min(w / wheelSize.w, h / wheelSize.h);\n        this._size = Math.max(wheelSize.w * scale, wheelSize.h * scale);\n        // Calculate the center of the wheel:\n        this._center = {\n            x: w / 2 + w * this.offset.w,\n            y: h / 2 + h * this.offset.h,\n        };\n        // Calculate the wheel radius:\n        this._actualRadius = (this._size / 2) * this.radius;\n        // Adjust the font size of labels so they all fit inside the wheel's radius:\n        this.itemLabelFontSize =\n            this.itemLabelFontSizeMax * (this._size / Constants.baseCanvasSize);\n        this.labelMaxWidth =\n            this._actualRadius * (this.itemLabelRadius - this.itemLabelRadiusMax);\n        for (const item of this._items) {\n            this.itemLabelFontSize = Math.min(this.itemLabelFontSize, util.getFontSizeToFit(item.label, this.itemLabelFont, this.labelMaxWidth, this._context));\n        }\n        this.refresh();\n    }\n    /**\n     * Main animation loop.\n     */\n    draw(now = 0) {\n        if (!this.canvas || !this._context) {\n            return;\n        }\n        this._frameRequestId = null;\n        const ctx = this._context;\n        // Clear canvas.\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.animateRotation(now);\n        const angles = this.getItemAngles(this._rotation);\n        const actualBorderWidth = this.getScaledNumber(this._borderWidth);\n        // Set font:\n        ctx.textBaseline = 'middle';\n        ctx.textAlign = this.itemLabelAlign;\n        ctx.font = this.itemLabelFontSize + 'px ' + this.itemLabelFont;\n        ctx.save();\n        // Build paths:\n        for (const [i, a] of angles.entries()) {\n            const path = new Path2D();\n            path.moveTo(this._center.x, this._center.y);\n            path.arc(this._center.x, this._center.y, this._actualRadius - actualBorderWidth / 2, util.degRad(a.start + Constants.arcAdjust), util.degRad(a.end + Constants.arcAdjust));\n            const item = this._items[i];\n            if (item !== undefined) {\n                item.path = path;\n            }\n        }\n        this.drawItemBackgrounds(ctx, angles);\n        this.drawItemImages(ctx, angles);\n        this.drawItemLines(ctx, angles);\n        this.drawItemLabels(ctx, angles);\n        this.drawBorder(ctx);\n        if (this._image) {\n            this.drawImage(ctx, this._image, false);\n        }\n        if (this._overlayImage) {\n            this.drawImage(ctx, this._overlayImage, true);\n        }\n        this.drawPointerLine(ctx);\n        this.drawDragEvents(ctx);\n        this._isInitialising = false;\n    }\n    drawItemBackgrounds(ctx, angles = []) {\n        for (const [i, a] of angles.entries()) {\n            const item = this._items[i];\n            ctx.fillStyle =\n                item.backgroundColor ??\n                    // Fall back to a value from the repeating set:\n                    this._itemBackgroundColors[i % this._itemBackgroundColors.length];\n            if (item.path !== undefined) {\n                ctx.fill(item.path);\n            }\n        }\n    }\n    drawItemImages(ctx, angles = []) {\n        for (const [i, a] of angles.entries()) {\n            const item = this._items[i];\n            if (!util.isImageLoaded(item.image))\n                continue;\n            ctx.save();\n            if (item.path !== undefined) {\n                ctx.clip(item.path);\n            }\n            const angle = a.start + (a.end - a.start) / 2;\n            ctx.translate(this._center.x +\n                Math.cos(util.degRad(angle + Constants.arcAdjust)) *\n                    (this._actualRadius * item.imageRadius), this._center.y +\n                Math.sin(util.degRad(angle + Constants.arcAdjust)) *\n                    (this._actualRadius * item.imageRadius));\n            ctx.rotate(util.degRad(angle + item.imageRotation));\n            ctx.globalAlpha = item.imageOpacity;\n            const width = item.image === null\n                ? 0\n                : (this._size / 500) * item.image.width * item.imageScale;\n            const height = item.image === null\n                ? 0\n                : (this._size / 500) * item.image.height * item.imageScale;\n            const widthHalf = -width / 2;\n            const heightHalf = -height / 2;\n            ctx.drawImage(item.image, widthHalf, heightHalf, width, height);\n            ctx.restore();\n        }\n    }\n    drawImage(ctx, image, isOverlay = false) {\n        if (!util.isImageLoaded(image))\n            return;\n        ctx.translate(this._center.x, this._center.y);\n        if (!isOverlay)\n            ctx.rotate(util.degRad(this._rotation));\n        // Draw the image centered and scaled to fit the wheel's container:\n        // For convenience, scale the 'normal' image to the size of the wheel radius\n        // (so a change in the wheel radius won't require the image to also be updated).\n        const size = isOverlay ? this._size : this._size * this.radius;\n        const sizeHalf = -(size / 2);\n        ctx.drawImage(image, sizeHalf, sizeHalf, size, size);\n        ctx.resetTransform();\n    }\n    drawPointerLine(ctx) {\n        if (!this.debug)\n            return;\n        ctx.translate(this._center.x, this._center.y);\n        ctx.rotate(util.degRad(this._pointerAngle + Constants.arcAdjust));\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(this._actualRadius * 2, 0);\n        ctx.strokeStyle = Constants.Debugging.pointerLineColor;\n        ctx.lineWidth = this.getScaledNumber(2);\n        ctx.stroke();\n        ctx.resetTransform();\n    }\n    drawBorder(ctx) {\n        if (this._borderWidth <= 0)\n            return;\n        const actualBorderWidth = this.getScaledNumber(this._borderWidth);\n        const actualBorderColor = this._borderColor || 'transparent';\n        ctx.beginPath();\n        ctx.strokeStyle = actualBorderColor;\n        ctx.lineWidth = actualBorderWidth;\n        ctx.arc(this._center.x, this._center.y, this._actualRadius - actualBorderWidth / 2, 0, 2 * Math.PI);\n        ctx.stroke();\n        if (this.debug) {\n            const actualDebugLineWidth = this.getScaledNumber(1);\n            ctx.beginPath();\n            ctx.strokeStyle = ctx.strokeStyle = Constants.Debugging.labelRadiusColor;\n            ctx.lineWidth = actualDebugLineWidth;\n            ctx.arc(this._center.x, this._center.y, this._actualRadius * this.itemLabelRadius, 0, 2 * Math.PI);\n            ctx.stroke();\n            ctx.beginPath();\n            ctx.strokeStyle = ctx.strokeStyle = Constants.Debugging.labelRadiusColor;\n            ctx.lineWidth = actualDebugLineWidth;\n            ctx.arc(this._center.x, this._center.y, this._actualRadius * this.itemLabelRadiusMax, 0, 2 * Math.PI);\n            ctx.stroke();\n        }\n    }\n    drawItemLines(ctx, angles = []) {\n        if (this._lineWidth <= 0)\n            return;\n        const actualLineWidth = this.getScaledNumber(this._lineWidth);\n        const actualBorderWidth = this.getScaledNumber(this._borderWidth);\n        ctx.translate(this._center.x, this._center.y);\n        for (const angle of angles) {\n            ctx.rotate(util.degRad(angle.start + Constants.arcAdjust));\n            ctx.beginPath();\n            ctx.moveTo(0, 0);\n            ctx.lineTo(this._actualRadius - actualBorderWidth, 0);\n            ctx.strokeStyle = this.lineColor;\n            ctx.lineWidth = actualLineWidth;\n            ctx.stroke();\n            ctx.rotate(-util.degRad(angle.start + Constants.arcAdjust));\n        }\n        ctx.resetTransform();\n    }\n    drawItemLabels(ctx, angles = []) {\n        const actualItemLabelBaselineOffset = this.itemLabelFontSize * -this.itemLabelBaselineOffset;\n        const actualDebugLineWidth = this.getScaledNumber(1);\n        const actualLabelStrokeWidth = this.getScaledNumber(this._itemLabelStrokeWidth * 2);\n        for (const [i, a] of angles.entries()) {\n            const item = this._items[i];\n            const actualLabelColor = item.labelColor ||\n                this._itemLabelColors[i % this._itemLabelColors.length] || // Fall back to a value from the repeating set.\n                'transparent'; // Handle empty string/undefined.\n            if (item.label.trim() === '' || actualLabelColor === 'transparent')\n                continue;\n            ctx.save();\n            if (item.path !== undefined) {\n                ctx.clip(item.path);\n            }\n            const angle = a.start + (a.end - a.start) / 2;\n            ctx.translate(this._center.x +\n                Math.cos(util.degRad(angle + Constants.arcAdjust)) *\n                    (this._actualRadius * this.itemLabelRadius), this._center.y +\n                Math.sin(util.degRad(angle + Constants.arcAdjust)) *\n                    (this._actualRadius * this.itemLabelRadius));\n            ctx.rotate(util.degRad(angle + Constants.arcAdjust));\n            ctx.rotate(util.degRad(this.itemLabelRotation));\n            if (this.debug) {\n                // Draw the outline of the label:\n                ctx.beginPath();\n                ctx.moveTo(0, 0);\n                ctx.lineTo(-this.labelMaxWidth, 0);\n                ctx.strokeStyle = Constants.Debugging.labelOutlineColor;\n                ctx.lineWidth = actualDebugLineWidth;\n                ctx.stroke();\n                ctx.strokeRect(0, -this.itemLabelFontSize / 2, -this.labelMaxWidth, this.itemLabelFontSize);\n            }\n            if (this._itemLabelStrokeWidth > 0) {\n                ctx.lineWidth = actualLabelStrokeWidth;\n                ctx.strokeStyle = this._itemLabelStrokeColor;\n                ctx.lineJoin = 'round';\n                ctx.strokeText(item.label, 0, actualItemLabelBaselineOffset);\n            }\n            ctx.fillStyle = actualLabelColor;\n            ctx.fillText(item.label, 0, actualItemLabelBaselineOffset);\n            ctx.restore();\n        }\n    }\n    drawDragEvents(ctx) {\n        if (!this.debug || !this.dragEvents?.length)\n            return;\n        const dragEventsReversed = [...this.dragEvents].reverse();\n        const actualLineWidth = this.getScaledNumber(0.5);\n        const actualCircleDiameter = this.getScaledNumber(4);\n        for (const [i, event] of dragEventsReversed.entries()) {\n            const percent = (i / this.dragEvents.length) * 100;\n            ctx.beginPath();\n            ctx.arc(event.x, event.y, actualCircleDiameter, 0, 2 * Math.PI);\n            ctx.fillStyle = `hsl(${Constants.Debugging.dragEventHue},100%,${percent}%)`;\n            ctx.strokeStyle = '#000';\n            ctx.lineWidth = actualLineWidth;\n            ctx.fill();\n            ctx.stroke();\n        }\n    }\n    animateRotation(now = 0) {\n        // For spinTo()\n        if (this._spinToTimeEnd !== null) {\n            // Check if we should end the animation:\n            if (now >= this._spinToTimeEnd) {\n                this.rotation = this._spinToEndRotation;\n                this._spinToTimeEnd = null;\n                this.onRest?.({\n                    type: 'rest',\n                    currentIndex: this._currentIndex,\n                    rotation: this._rotation,\n                });\n                return;\n            }\n            const duration = this._spinToTimeEnd - this._spinToTimeStart;\n            let delta = (now - this._spinToTimeStart) / duration;\n            delta = delta < 0 ? 0 : delta; // Frame time may be before the start time.\n            const distance = this._spinToEndRotation - this._spinToStartRotation;\n            this.rotation =\n                this._spinToStartRotation +\n                    distance * this._spinToEasingFunction(delta);\n            this.refresh();\n            return;\n        }\n        // For spin()\n        if (this._lastSpinFrameTime !== null) {\n            const delta = now - this._lastSpinFrameTime;\n            if (delta > 0) {\n                this.rotation += ((delta / 1000) * this._rotationSpeed) % 360; // TODO: very small rounding errors can accumulative here.\n                this._rotationSpeed = this.getRotationSpeedPlusDrag(delta);\n                // Check if we should end the animation:\n                if (this._rotationSpeed === 0) {\n                    this.onRest?.({\n                        type: 'rest',\n                        currentIndex: this._currentIndex,\n                        rotation: this._rotation,\n                    });\n                    this._lastSpinFrameTime = null;\n                }\n                else {\n                    this._lastSpinFrameTime = now;\n                }\n            }\n            this.refresh();\n            return;\n        }\n    }\n    getRotationSpeedPlusDrag(delta = 0) {\n        // Simulate drag:\n        const newRotationSpeed = this._rotationSpeed +\n            this.rotationResistance * (delta / 1000) * this._rotationDirection;\n        // Stop rotation once speed reaches 0.\n        // Otherwise the wheel could rotate in the opposite direction next frame.\n        if ((this._rotationDirection === 1 && newRotationSpeed < 0) ||\n            (this._rotationDirection === -1 && newRotationSpeed >= 0)) {\n            return 0;\n        }\n        return newRotationSpeed;\n    }\n    /**\n     * Spin the wheel by setting `rotationSpeed`.\n     * The wheel will immediately start spinning, and slow down over time depending on the value of `rotationResistance`.\n     * A positive number will spin clockwise, a negative number will spin anticlockwise.\n     */\n    spin(rotationSpeed = 0) {\n        if (!util.isNumber(rotationSpeed))\n            throw new Error('rotationSpeed must be a number');\n        this.dragEvents = [];\n        this.beginSpin(rotationSpeed, 'spin');\n    }\n    /**\n     * Spin the wheel to a particular rotation.\n     * The animation will occur over the provided `duration` (milliseconds).\n     * The animation can be adjusted by providing an optional `easingFunction` which accepts a single parameter n, where n is between 0 and 1 inclusive.\n     * If no easing function is provided, the default easeSinOut will be used.\n     * For example easing functions see [easing-utils](https://github.com/AndrewRayCode/easing-utils).\n     */\n    spinTo(rotation, duration, easingFunction = null) {\n        if (!util.isNumber(rotation))\n            throw new Error('Error: rotation must be a number');\n        if (!util.isNumber(duration))\n            throw new Error('Error: duration must be a number');\n        this.stop();\n        this.dragEvents = [];\n        this.animate(rotation, duration, easingFunction);\n        this.onSpin?.({\n            type: 'spin',\n            method: 'spinto',\n            targetRotation: rotation,\n            duration,\n        });\n    }\n    /**\n     * Spin the wheel to a particular item.\n     * The animation will occur over the provided `duration` (milliseconds).\n     * If `spinToCenter` is true, the wheel will spin to the center of the item, otherwise the wheel will spin to a random angle inside the item.\n     * `numberOfRevolutions` controls how many times the wheel will rotate a full 360 degrees before resting on the item.\n     * The animation can be adjusted by providing an optional `easingFunction` which accepts a single parameter n, where n is between 0 and 1 inclusive.\n     * If no easing function is provided, the default easeSinOut will be used.\n     * For example easing functions see [easing-utils](https://github.com/AndrewRayCode/easing-utils).\n     */\n    spinToItem(itemIndex = 0, duration = 0, spinToCenter = true, numberOfRevolutions = 1, direction = 1, easingFunction = null) {\n        this.stop();\n        this.dragEvents = [];\n        const itemAngle = spinToCenter\n            ? this.items[itemIndex].getCenterAngle()\n            : this.items[itemIndex].getRandomAngle();\n        let newRotation = util.calcWheelRotationForTargetAngle(this.rotation, itemAngle - this._pointerAngle, direction);\n        newRotation += numberOfRevolutions * 360 * direction;\n        this.animate(newRotation, duration, easingFunction);\n        this.onSpin?.({\n            type: 'spin',\n            method: 'spintoitem',\n            targetItemIndex: itemIndex,\n            targetRotation: newRotation,\n            duration,\n        });\n    }\n    animate(newRotation, duration, easingFunction) {\n        this._spinToStartRotation = this.rotation;\n        this._spinToEndRotation = newRotation;\n        this._spinToTimeStart = performance.now();\n        this._spinToTimeEnd = this._spinToTimeStart + duration;\n        this._spinToEasingFunction = easingFunction || util.easeSinOut;\n        this.refresh();\n    }\n    /**\n     * Immediately stop the wheel from spinning, regardless of which method was used to spin it.\n     */\n    stop() {\n        // Stop the wheel if it was spun via `spinTo()`.\n        this._spinToTimeEnd = null;\n        // Stop the wheel if it was spun via `spin()`.\n        this._rotationSpeed = 0;\n        this._lastSpinFrameTime = null;\n    }\n    /**\n     * Return n scaled to the size of the canvas.\n     */\n    getScaledNumber(n) {\n        return (n / Constants.baseCanvasSize) * this._size;\n    }\n    getActualPixelRatio() {\n        return this._pixelRatio !== 0 ? this._pixelRatio : window.devicePixelRatio;\n    }\n    /**\n     * Return true if the given point is inside the wheel.\n     */\n    wheelHitTest(point = { x: 0, y: 0 }) {\n        if (!this.canvas) {\n            return false;\n        }\n        const p = util.translateXYToElement(point, this.canvas, this.getActualPixelRatio());\n        return util.isPointInCircle(p, this._center.x, this._center.y, this._actualRadius);\n    }\n    /**\n     * Refresh the cursor state.\n     * Call this after the pointer moves.\n     */\n    refreshCursor() {\n        if (!this.canvas) {\n            return;\n        }\n        if (this.isInteractive) {\n            if (this.isDragging) {\n                this.canvas.style.cursor = 'grabbing';\n                return;\n            }\n            if (this._isCursorOverWheel) {\n                this.canvas.style.cursor = 'grab';\n                return;\n            }\n        }\n        this.canvas.style.cursor = '';\n    }\n    /**\n     * Get the angle (in degrees) of the given point from the center of the wheel.\n     * 0 is north.\n     */\n    getAngleFromCenter(point = { x: 0, y: 0 }) {\n        return ((util.getAngle(this._center.x, this._center.y, point.x, point.y) + 90) %\n            360);\n    }\n    /**\n     * Get the index of the item that the Pointer is pointing at.\n     * An item is considered \"current\" if `pointerAngle` is between it's start angle (inclusive)\n     * and it's end angle (exclusive).\n     */\n    getCurrentIndex() {\n        return this._currentIndex;\n    }\n    /**\n     * Calculate and set `currentIndex`\n     */\n    refreshCurrentIndex(angles = []) {\n        if (this._items.length === 0)\n            this._currentIndex = -1;\n        for (const [i, a] of angles.entries()) {\n            if (!util.isAngleBetween(this._pointerAngle, a.start % 360, a.end % 360))\n                continue;\n            if (this._currentIndex === i)\n                break;\n            this._currentIndex = i;\n            if (!this._isInitialising) {\n                this.onCurrentIndexChange?.({\n                    type: 'currentIndexChange',\n                    currentIndex: this._currentIndex,\n                });\n            }\n            break;\n        }\n    }\n    /**\n     * Return an array of objects containing the start angle (inclusive) and end angle (inclusive) of each item.\n     */\n    getItemAngles(initialRotation = 0) {\n        let weightSum = 0;\n        for (const i of this.items) {\n            weightSum += i.weight;\n        }\n        const weightedItemAngle = 360 / weightSum;\n        let itemAngle;\n        let lastItemAngle = initialRotation;\n        const angles = [];\n        for (const item of this._items) {\n            itemAngle = item.weight * weightedItemAngle;\n            angles.push({\n                start: lastItemAngle,\n                end: lastItemAngle + itemAngle,\n            });\n            lastItemAngle += itemAngle;\n        }\n        // Ensure the difference between last angle.end and first angle.start is exactly 360 degrees.\n        // Sometimes floating point arithmetic pushes the end value past 360 degrees by\n        // a very small amount, which causes issues when calculating `currentIndex`.\n        if (this._items.length > 1) {\n            // @ts-ignore\n            angles[angles.length - 1].end = angles[0].start + 360;\n        }\n        return angles;\n    }\n    /**\n     * Schedule a redraw of the wheel on the canvas.\n     * Call this after changing any property of the wheel that relates to it's appearance.\n     */\n    refresh() {\n        if (this._frameRequestId === null) {\n            this._frameRequestId = window.requestAnimationFrame((t) => this.draw(t));\n        }\n    }\n    limitSpeed(speed = 0, max = 0) {\n        // Max is always a positive number, but speed may be positive or negative.\n        const newSpeed = Math.min(speed, max);\n        return Math.max(newSpeed, -max);\n    }\n    beginSpin(speed = 0, spinMethod) {\n        this.stop();\n        this._rotationSpeed = this.limitSpeed(speed, this._rotationSpeedMax);\n        this._lastSpinFrameTime = performance.now();\n        this._rotationDirection = this._rotationSpeed >= 0 ? 1 : -1; // 1 for clockwise or stationary, -1 for anticlockwise.\n        if (this._rotationSpeed !== 0) {\n            this.onSpin?.({\n                type: 'spin',\n                method: spinMethod,\n                rotationSpeed: this._rotationSpeed,\n                rotationResistance: this._rotationResistance,\n            });\n        }\n        this.refresh();\n    }\n    refreshAriaLabel() {\n        if (!this.canvas) {\n            return;\n        }\n        // See https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/img_role\n        this.canvas.setAttribute('role', 'img');\n        const wheelDescription = this.items.length >= 2\n            ? ` The wheel has ${this.items.length} slices.`\n            : '';\n        this.canvas.setAttribute('aria-label', 'An image of a spinning prize wheel.' + wheelDescription);\n    }\n    /**\n     * The color of the line around the circumference of the wheel.\n     */\n    get borderColor() {\n        return this._borderColor;\n    }\n    set borderColor(val) {\n        this._borderColor = util.setProp({\n            val,\n            isValid: typeof val === 'string',\n            errorMessage: 'Wheel.borderColor must be a string',\n            defaultValue: Defaults.wheel.borderColor,\n        });\n        this.refresh();\n    }\n    /**\n     * The width (in pixels) of the line around the circumference of the wheel.\n     */\n    get borderWidth() {\n        return this._borderWidth;\n    }\n    set borderWidth(val) {\n        this._borderWidth = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.borderWidth must be a number',\n            defaultValue: Defaults.wheel.borderWidth,\n        });\n        this.refresh();\n    }\n    /**\n     * Show debugging info.\n     * This is particularly helpful when fine-tuning labels.\n     */\n    get debug() {\n        return this._debug;\n    }\n    set debug(val) {\n        this._debug = util.setProp({\n            val,\n            isValid: typeof val === 'boolean',\n            errorMessage: 'Wheel.debug must be a boolean',\n            defaultValue: Defaults.wheel.debug,\n        });\n        this.refresh();\n    }\n    /**\n     * The url of an image that will be drawn over the center of the wheel which will rotate with the wheel.\n     * It will be automatically scaled to fit `radius`.\n     */\n    get image() {\n        return this._image;\n    }\n    set image(val) {\n        if (typeof val !== 'string' && !!val) {\n            throw new Error('Wheel.image must be a url (string) or null');\n        }\n        if (!val) {\n            this._image = null;\n        }\n        else {\n            const v = new Image();\n            v.src = val;\n            v.onload = (e) => {\n                this.refresh();\n            };\n            this._image = v;\n        }\n        this.refresh();\n    }\n    /**\n     * Allow the user to spin the wheel using click-drag/touch-flick.\n     * User interaction will only be detected within the bounds of `Wheel.radius`.\n     */\n    get isInteractive() {\n        return this._isInteractive;\n    }\n    set isInteractive(val) {\n        this._isInteractive = util.setProp({\n            val,\n            isValid: typeof val === 'boolean',\n            errorMessage: 'Wheel.isInteractive must be a boolean',\n            defaultValue: Defaults.wheel.isInteractive,\n        });\n        this.refreshCursor(); // Reset the cursor in case the wheel is currently being dragged.\n    }\n    /**\n     * The repeating pattern of background colors for all items.\n     * Overridden by `Item.backgroundColor`.\n     * Example: `['#fff','#000']`.\n     */\n    get itemBackgroundColors() {\n        return this._itemBackgroundColors;\n    }\n    set itemBackgroundColors(val) {\n        this._itemBackgroundColors = util.setProp({\n            val,\n            isValid: Array.isArray(val),\n            errorMessage: 'Wheel.itemBackgroundColors must be an array',\n            defaultValue: Defaults.wheel.itemBackgroundColors,\n        });\n        this.refresh();\n    }\n    /**\n     * The alignment of all item labels.\n     * Accepted values: `'left'`,`'center'`,`'right'`.\n     */\n    get itemLabelAlign() {\n        return this._itemLabelAlign;\n    }\n    set itemLabelAlign(val) {\n        this._itemLabelAlign = util.setProp({\n            val,\n            isValid: typeof val === 'string',\n            errorMessage: 'Wheel.itemLabelAlign must be a string',\n            defaultValue: Defaults.wheel.itemLabelAlign,\n        });\n        this.refresh();\n    }\n    /**\n     * The offset of the baseline (or line height) of all item labels (as a percent of the label's height).\n     */\n    get itemLabelBaselineOffset() {\n        return this._itemLabelBaselineOffset;\n    }\n    set itemLabelBaselineOffset(val) {\n        this._itemLabelBaselineOffset = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.itemLabelBaselineOffset must be a number',\n            defaultValue: Defaults.wheel.itemLabelBaselineOffset,\n        });\n        this.resize();\n    }\n    /**\n     * The repeating pattern of colors for all item labels.\n     * Overridden by `Item.labelColor`.\n     * Example: `['#fff','#000']`.\n     */\n    get itemLabelColors() {\n        return this._itemLabelColors;\n    }\n    set itemLabelColors(val) {\n        this._itemLabelColors = util.setProp({\n            val,\n            isValid: Array.isArray(val),\n            errorMessage: 'Wheel.itemLabelColors must be an array',\n            defaultValue: Defaults.wheel.itemLabelColors,\n        });\n        this.refresh();\n    }\n    /**\n     * The font family for all item labels.\n     * Overridden by `Item.labelFont`.\n     * Example: `'sans-serif'`.\n     */\n    get itemLabelFont() {\n        return this._itemLabelFont;\n    }\n    set itemLabelFont(val) {\n        this._itemLabelFont = util.setProp({\n            val,\n            isValid: typeof val === 'string',\n            errorMessage: 'Wheel.itemLabelFont must be a string',\n            defaultValue: Defaults.wheel.itemLabelFont,\n        });\n        this.resize();\n    }\n    /**\n     * The maximum font size (in pixels) for all item labels.\n     */\n    get itemLabelFontSizeMax() {\n        return this._itemLabelFontSizeMax;\n    }\n    set itemLabelFontSizeMax(val) {\n        this._itemLabelFontSizeMax = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.itemLabelFontSizeMax must be a number',\n            defaultValue: Defaults.wheel.itemLabelFontSizeMax,\n        });\n        this.resize();\n    }\n    /**\n     * The point along the radius (as a percent, starting from the center of the wheel)\n     * to start drawing all item labels.\n     */\n    get itemLabelRadius() {\n        return this._itemLabelRadius;\n    }\n    set itemLabelRadius(val) {\n        this._itemLabelRadius = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.itemLabelRadius must be a number',\n            defaultValue: Defaults.wheel.itemLabelRadius,\n        });\n        this.resize();\n    }\n    /**\n     * The point along the radius (as a percent, starting from the center of the wheel)\n     * to calculate the maximum font size for all item labels.\n     */\n    get itemLabelRadiusMax() {\n        return this._itemLabelRadiusMax;\n    }\n    set itemLabelRadiusMax(val) {\n        this._itemLabelRadiusMax = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.itemLabelRadiusMax must be a number',\n            defaultValue: Defaults.wheel.itemLabelRadiusMax,\n        });\n        this.resize();\n    }\n    /**\n     * The rotation of all item labels.\n     * Use this in combination with `itemLabelAlign` to flip the labels `180°`.\n     */\n    get itemLabelRotation() {\n        return this._itemLabelRotation;\n    }\n    set itemLabelRotation(val) {\n        this._itemLabelRotation = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.itemLabelRotation must be a number',\n            defaultValue: Defaults.wheel.itemLabelRotation,\n        });\n        this.refresh();\n    }\n    /**\n     * The color of the stroke applied to the outside of the label text.\n     */\n    get itemLabelStrokeColor() {\n        return this._itemLabelStrokeColor;\n    }\n    set itemLabelStrokeColor(val) {\n        this._itemLabelStrokeColor = util.setProp({\n            val,\n            isValid: typeof val === 'string',\n            errorMessage: 'Wheel.itemLabelStrokeColor must be a string',\n            defaultValue: Defaults.wheel.itemLabelStrokeColor,\n        });\n        this.refresh();\n    }\n    /**\n     * The width of the stroke applied to the outside of the label text.\n     */\n    get itemLabelStrokeWidth() {\n        return this._itemLabelStrokeWidth;\n    }\n    set itemLabelStrokeWidth(val) {\n        this._itemLabelStrokeWidth = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.itemLabelStrokeWidth must be a number',\n            defaultValue: Defaults.wheel.itemLabelStrokeWidth,\n        });\n        this.refresh();\n    }\n    /**\n     * The items to show on the wheel.\n     */\n    get items() {\n        return this._items;\n    }\n    set items(val) {\n        this._items = (val ?? []).map((item) => new Item(this, item));\n        this.refreshAriaLabel();\n        this.refreshCurrentIndex(this.getItemAngles(this._rotation));\n        this.resize(); // Refresh item label font size.\n    }\n    /**\n     * The color of the lines between the items.\n     */\n    get lineColor() {\n        return this._lineColor;\n    }\n    set lineColor(val) {\n        this._lineColor = util.setProp({\n            val,\n            isValid: typeof val === 'string',\n            errorMessage: 'Wheel.lineColor must be a string',\n            defaultValue: Defaults.wheel.lineColor,\n        });\n        this.refresh();\n    }\n    /**\n     * The width (in pixels) of the lines between the items.\n     */\n    get lineWidth() {\n        return this._lineWidth;\n    }\n    set lineWidth(val) {\n        this._lineWidth = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.lineWidth must be a number',\n            defaultValue: Defaults.wheel.lineWidth,\n        });\n        this.refresh();\n    }\n    /**\n     * The offset of the wheel relative to it's center (as a percent of the wheel's diameter).\n     */\n    get offset() {\n        return this._offset;\n    }\n    set offset(val) {\n        this._offset = util.setProp({\n            val,\n            isValid: util.isObject(val),\n            errorMessage: 'Wheel.offset must be an object',\n            defaultValue: Defaults.wheel.offset,\n        });\n        this.resize();\n    }\n    /**\n     * The callback for the `onCurrentIndexChange` event.\n     */\n    get onCurrentIndexChange() {\n        return this._onCurrentIndexChange;\n    }\n    set onCurrentIndexChange(val) {\n        this._onCurrentIndexChange = util.setProp({\n            val,\n            isValid: typeof val === 'function' || val === null,\n            errorMessage: 'Wheel.onCurrentIndexChange must be a function or null',\n            defaultValue: Defaults.wheel.onCurrentIndexChange,\n        });\n    }\n    /**\n     * The callback for the `onRest` event.\n     */\n    get onRest() {\n        return this._onRest;\n    }\n    set onRest(val) {\n        this._onRest = util.setProp({\n            val,\n            isValid: typeof val === 'function' || val === null,\n            errorMessage: 'Wheel.onRest must be a function or null',\n            defaultValue: Defaults.wheel.onRest,\n        });\n    }\n    /**\n     * The callback for the `onSpin` event.\n     */\n    get onSpin() {\n        return this._onSpin;\n    }\n    set onSpin(val) {\n        this._onSpin = util.setProp({\n            val,\n            isValid: typeof val === 'function' || val === null,\n            errorMessage: 'Wheel.onSpin must be a function or null',\n            defaultValue: Defaults.wheel.onSpin,\n        });\n    }\n    /**\n     * The url of an image that will be drawn over the center of the wheel which will not rotate with the wheel.\n     * It will be automatically scaled to fit the container's smallest dimension.\n     * Use this to draw decorations around the wheel, such as a stand or pointer.\n     */\n    get overlayImage() {\n        return this._overlayImage?.src ?? null;\n    }\n    set overlayImage(val) {\n        if (typeof val !== 'string' && !!val) {\n            throw new Error('Wheel.overlayImage must be a url (string) or null');\n        }\n        if (!val) {\n            this._overlayImage = null;\n        }\n        else {\n            const v = new Image();\n            v.src = val;\n            v.onload = (e) => {\n                this.refresh();\n            };\n            this._overlayImage = v;\n        }\n        this.refresh();\n    }\n    /**\n     * The pixel ratio used to render the wheel.\n     * Values above 0 will produce a sharper image at the cost of performance.\n     * A value of `0` will cause the pixel ratio to be automatically determined using `window.devicePixelRatio`.\n     */\n    get pixelRatio() {\n        return this._pixelRatio;\n    }\n    set pixelRatio(val) {\n        this._pixelRatio = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.pixelRatio must be a number',\n            defaultValue: Defaults.wheel.pixelRatio,\n        });\n        this.dragEvents = [];\n        this.resize();\n    }\n    /**\n     * The angle of the Pointer which is used to determine the `currentIndex` (or the \"winning\" item).\n     */\n    get pointerAngle() {\n        return this._pointerAngle;\n    }\n    set pointerAngle(val) {\n        this._pointerAngle = util.setProp({\n            val,\n            isValid: val === undefined || (util.isNumber(val) && val >= 0),\n            errorMessage: 'Wheel.pointerAngle must be a number between 0 and 360',\n            defaultValue: Defaults.wheel.pointerAngle,\n            action: () => (val ?? Defaults.wheel.pointerAngle) % 360,\n        });\n        if (this.debug)\n            this.refresh();\n    }\n    /**\n     * The radius of the wheel (as a percent of the container's smallest dimension).\n     */\n    get radius() {\n        return this._radius;\n    }\n    set radius(val) {\n        this._radius = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.radius must be a number',\n            defaultValue: Defaults.wheel.radius,\n        });\n        this.resize();\n    }\n    /**\n     * The rotation (angle in degrees) of the wheel.\n     * `0` is north.\n     * The first item will be drawn clockwise from this point.\n     */\n    get rotation() {\n        return this._rotation;\n    }\n    set rotation(val) {\n        this._rotation = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.rotation must be a number',\n            defaultValue: Defaults.wheel.rotation,\n        });\n        this.refreshCurrentIndex(this.getItemAngles(this._rotation));\n        this.refresh();\n    }\n    /**\n     * The amount that `rotationSpeed` will be reduced by every second.\n     * Only in effect when `rotationSpeed !== 0`.\n     * Set to `0` to spin the wheel infinitely.\n     */\n    get rotationResistance() {\n        return this._rotationResistance;\n    }\n    set rotationResistance(val) {\n        this._rotationResistance = util.setProp({\n            val,\n            isValid: util.isNumber(val),\n            errorMessage: 'Wheel.rotationResistance must be a number',\n            defaultValue: Defaults.wheel.rotationResistance,\n        });\n    }\n    /**\n     * (Readonly) How far (angle in degrees) the wheel will spin every 1 second.\n     * A positive number means the wheel is spinning clockwise, a negative number means anticlockwise, and `0` means the wheel is not spinning.\n     */\n    get rotationSpeed() {\n        return this._rotationSpeed;\n    }\n    /**\n     * The maximum value for `rotationSpeed` (ignoring the wheel's spin direction).\n     * The wheel will not spin faster than this value in any direction.\n     */\n    get rotationSpeedMax() {\n        return this._rotationSpeedMax;\n    }\n    set rotationSpeedMax(val) {\n        this._rotationSpeedMax = util.setProp({\n            val,\n            isValid: val === undefined || (util.isNumber(val) && val >= 0),\n            errorMessage: 'Wheel.rotationSpeedMax must be a number >= 0',\n            defaultValue: Defaults.wheel.rotationSpeedMax,\n        });\n    }\n    /**\n     * Enter the drag state.\n     */\n    dragStart(point = { x: 0, y: 0 }) {\n        if (!this.canvas) {\n            return;\n        }\n        const p = util.translateXYToElement(point, this.canvas, this.getActualPixelRatio());\n        this.isDragging = true;\n        this.stop(); // Interrupt `spinTo()`\n        this.dragEvents = [\n            {\n                distance: 0,\n                x: p.x,\n                y: p.y,\n                now: performance.now(),\n            },\n        ];\n        this.refreshCursor();\n    }\n    dragMove(point = { x: 0, y: 0 }) {\n        if (!this.canvas) {\n            return;\n        }\n        const p = util.translateXYToElement(point, this.canvas, this.getActualPixelRatio());\n        const a = this.getAngleFromCenter(p);\n        const lastDragPoint = this.dragEvents[0];\n        const lastAngle = this.getAngleFromCenter(lastDragPoint);\n        const angleSinceLastMove = util.diffAngle(lastAngle, a);\n        this.dragEvents.unshift({\n            distance: angleSinceLastMove,\n            x: p.x,\n            y: p.y,\n            now: performance.now(),\n        });\n        // Retain max 40 drag events.\n        if (this.debug && this.dragEvents.length >= 40)\n            this.dragEvents.pop();\n        // Snap the wheel to the new rotation.\n        this.rotation += angleSinceLastMove; // TODO: can we apply easing here so it looks nicer?\n    }\n    /**\n     * Exit the drag state.\n     * Set the rotation speed so the wheel continues to spin in the same direction.\n     */\n    dragEnd() {\n        this.isDragging = false;\n        // Calc the drag distance:\n        let dragDistance = 0;\n        const now = performance.now();\n        for (const [i, event] of this.dragEvents.entries()) {\n            if (!this.isDragEventTooOld(now, event)) {\n                dragDistance += event.distance;\n                continue;\n            }\n            // Exclude old events:\n            this.dragEvents.length = i;\n            if (this.debug)\n                this.refresh(); // Redraw drag events after trimming the array.\n            break;\n        }\n        this.refreshCursor();\n        if (dragDistance === 0)\n            return;\n        this.beginSpin(dragDistance * (1000 / Constants.dragCapturePeriod), 'interact');\n    }\n    isDragEventTooOld(now = 0, event) {\n        return now - event.now > Constants.dragCapturePeriod;\n    }\n}\nexport { Wheel, Item };\n"],
  "mappings": "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",
  "names": ["e"]
}
